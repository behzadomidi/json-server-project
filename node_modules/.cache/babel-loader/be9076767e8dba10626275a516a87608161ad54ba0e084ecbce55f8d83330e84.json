{"ast":null,"code":"import _objectSpread from \"/Users/behzad/Desktop/swr/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _regeneratorRuntime from \"/Users/behzad/Desktop/swr/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"/Users/behzad/Desktop/swr/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _slicedToArray from \"/Users/behzad/Desktop/swr/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport { useRef, useCallback } from 'react';\nimport useSWR from 'swr';\nimport { withMiddleware, createCacheHelper, isUndefined, useIsomorphicLayoutEffect, serialize, UNDEFINED, isFunction } from 'swr/_internal';\nimport { useSyncExternalStore } from 'use-sync-external-store/shim/index.js';\n\n// We have to several type castings here because `useSWRInfinite` is a special\nvar INFINITE_PREFIX = '$inf$';\nvar EMPTY_PROMISE = Promise.resolve();\nvar getFirstPageKey = function getFirstPageKey(getKey) {\n  return serialize(getKey ? getKey(0, null) : null)[0];\n};\nvar unstable_serialize = function unstable_serialize(getKey) {\n  return INFINITE_PREFIX + getFirstPageKey(getKey);\n};\nvar infinite = function infinite(useSWRNext) {\n  return function (getKey, fn, config) {\n    var didMountRef = useRef(false);\n    var cache = config.cache,\n      _config$initialSize = config.initialSize,\n      initialSize = _config$initialSize === void 0 ? 1 : _config$initialSize,\n      _config$revalidateAll = config.revalidateAll,\n      revalidateAll = _config$revalidateAll === void 0 ? false : _config$revalidateAll,\n      _config$persistSize = config.persistSize,\n      persistSize = _config$persistSize === void 0 ? false : _config$persistSize,\n      _config$revalidateFir = config.revalidateFirstPage,\n      revalidateFirstPage = _config$revalidateFir === void 0 ? true : _config$revalidateFir,\n      _config$revalidateOnM = config.revalidateOnMount,\n      revalidateOnMount = _config$revalidateOnM === void 0 ? false : _config$revalidateOnM,\n      _config$parallel = config.parallel,\n      parallel = _config$parallel === void 0 ? false : _config$parallel;\n    // The serialized key of the first page. This key will be used to store\n    // metadata of this SWR infinite hook.\n    var infiniteKey;\n    try {\n      infiniteKey = getFirstPageKey(getKey);\n      if (infiniteKey) infiniteKey = INFINITE_PREFIX + infiniteKey;\n    } catch (err) {\n      // Not ready yet.\n    }\n    var _createCacheHelper = createCacheHelper(cache, infiniteKey),\n      _createCacheHelper2 = _slicedToArray(_createCacheHelper, 3),\n      get = _createCacheHelper2[0],\n      set = _createCacheHelper2[1],\n      subscribeCache = _createCacheHelper2[2];\n    var getSnapshot = useCallback(function () {\n      var size = isUndefined(get()._l) ? initialSize : get()._l;\n      return size;\n      // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [cache, infiniteKey, initialSize]);\n    useSyncExternalStore(useCallback(function (callback) {\n      if (infiniteKey) return subscribeCache(infiniteKey, function () {\n        callback();\n      });\n      return function () {};\n    },\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [cache, infiniteKey]), getSnapshot, getSnapshot);\n    var resolvePageSize = useCallback(function () {\n      var cachedPageSize = get()._l;\n      return isUndefined(cachedPageSize) ? initialSize : cachedPageSize;\n      // `cache` isn't allowed to change during the lifecycle\n      // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [infiniteKey, initialSize]);\n    // keep the last page size to restore it with the persistSize option\n    var lastPageSizeRef = useRef(resolvePageSize());\n    // When the page key changes, we reset the page size if it's not persisted\n    useIsomorphicLayoutEffect(function () {\n      if (!didMountRef.current) {\n        didMountRef.current = true;\n        return;\n      }\n      if (infiniteKey) {\n        // If the key has been changed, we keep the current page size if persistSize is enabled\n        // Otherwise, we reset the page size to cached pageSize\n        set({\n          _l: persistSize ? lastPageSizeRef.current : resolvePageSize()\n        });\n      }\n      // `initialSize` isn't allowed to change during the lifecycle\n      // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [infiniteKey, cache]);\n    // Needs to check didMountRef during mounting, not in the fetcher\n    var shouldRevalidateOnMount = revalidateOnMount && !didMountRef.current;\n    // Actual SWR hook to load all pages in one fetcher.\n    var swr = useSWRNext(infiniteKey, /*#__PURE__*/function () {\n      var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(key) {\n        var forceRevalidateAll, data, pageSize, _createCacheHelper3, _createCacheHelper4, getCache, cacheData, revalidators, previousPageData, _loop, i, _ret;\n        return _regeneratorRuntime().wrap(function _callee2$(_context3) {\n          while (1) switch (_context3.prev = _context3.next) {\n            case 0:\n              // get the revalidate context\n              forceRevalidateAll = get()._i; // return an array of page data\n              data = [];\n              pageSize = resolvePageSize();\n              _createCacheHelper3 = createCacheHelper(cache, key), _createCacheHelper4 = _slicedToArray(_createCacheHelper3, 1), getCache = _createCacheHelper4[0];\n              cacheData = getCache().data;\n              revalidators = [];\n              previousPageData = null;\n              _loop = /*#__PURE__*/_regeneratorRuntime().mark(function _loop(i) {\n                var _serialize, _serialize2, pageKey, pageArg, _createCacheHelper5, _createCacheHelper6, getSWRCache, setSWRCache, pageData, shouldFetchPage, revalidate;\n                return _regeneratorRuntime().wrap(function _loop$(_context2) {\n                  while (1) switch (_context2.prev = _context2.next) {\n                    case 0:\n                      _serialize = serialize(getKey(i, parallel ? null : previousPageData)), _serialize2 = _slicedToArray(_serialize, 2), pageKey = _serialize2[0], pageArg = _serialize2[1];\n                      if (pageKey) {\n                        _context2.next = 3;\n                        break;\n                      }\n                      return _context2.abrupt(\"return\", \"break\");\n                    case 3:\n                      _createCacheHelper5 = createCacheHelper(cache, pageKey), _createCacheHelper6 = _slicedToArray(_createCacheHelper5, 2), getSWRCache = _createCacheHelper6[0], setSWRCache = _createCacheHelper6[1]; // Get the cached page data.\n                      pageData = getSWRCache().data; // should fetch (or revalidate) if:\n                      // - `revalidateAll` is enabled\n                      // - `mutate()` called\n                      // - the cache is missing\n                      // - it's the first page and it's not the initial render\n                      // - `revalidateOnMount` is enabled and it's on mount\n                      // - cache for that page has changed\n                      shouldFetchPage = revalidateAll || forceRevalidateAll || isUndefined(pageData) || revalidateFirstPage && !i && !isUndefined(cacheData) || shouldRevalidateOnMount || cacheData && !isUndefined(cacheData[i]) && !config.compare(cacheData[i], pageData);\n                      if (!(fn && shouldFetchPage)) {\n                        _context2.next = 16;\n                        break;\n                      }\n                      revalidate = /*#__PURE__*/function () {\n                        var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n                          return _regeneratorRuntime().wrap(function _callee$(_context) {\n                            while (1) switch (_context.prev = _context.next) {\n                              case 0:\n                                _context.next = 2;\n                                return fn(pageArg);\n                              case 2:\n                                pageData = _context.sent;\n                                setSWRCache({\n                                  data: pageData,\n                                  _k: pageArg\n                                });\n                                data[i] = pageData;\n                              case 5:\n                              case \"end\":\n                                return _context.stop();\n                            }\n                          }, _callee);\n                        }));\n                        return function revalidate() {\n                          return _ref2.apply(this, arguments);\n                        };\n                      }();\n                      if (!parallel) {\n                        _context2.next = 12;\n                        break;\n                      }\n                      revalidators.push(revalidate);\n                      _context2.next = 14;\n                      break;\n                    case 12:\n                      _context2.next = 14;\n                      return revalidate();\n                    case 14:\n                      _context2.next = 17;\n                      break;\n                    case 16:\n                      data[i] = pageData;\n                    case 17:\n                      if (!parallel) {\n                        previousPageData = pageData;\n                      }\n                    case 18:\n                    case \"end\":\n                      return _context2.stop();\n                  }\n                }, _loop);\n              });\n              i = 0;\n            case 9:\n              if (!(i < pageSize)) {\n                _context3.next = 17;\n                break;\n              }\n              return _context3.delegateYield(_loop(i), \"t0\", 11);\n            case 11:\n              _ret = _context3.t0;\n              if (!(_ret === \"break\")) {\n                _context3.next = 14;\n                break;\n              }\n              return _context3.abrupt(\"break\", 17);\n            case 14:\n              ++i;\n              _context3.next = 9;\n              break;\n            case 17:\n              if (!parallel) {\n                _context3.next = 20;\n                break;\n              }\n              _context3.next = 20;\n              return Promise.all(revalidators.map(function (r) {\n                return r();\n              }));\n            case 20:\n              // once we executed the data fetching based on the context, clear the context\n              set({\n                _i: UNDEFINED\n              });\n              // return the data\n              return _context3.abrupt(\"return\", data);\n            case 22:\n            case \"end\":\n              return _context3.stop();\n          }\n        }, _callee2);\n      }));\n      return function (_x) {\n        return _ref.apply(this, arguments);\n      };\n    }(), config);\n    var mutate = useCallback(\n    // eslint-disable-next-line func-names\n    function (data, opts) {\n      // When passing as a boolean, it's explicitly used to disable/enable\n      // revalidation.\n      var options = typeof opts === 'boolean' ? {\n        revalidate: opts\n      } : opts || {};\n      // Default to true.\n      var shouldRevalidate = options.revalidate !== false;\n      // It is possible that the key is still falsy.\n      if (!infiniteKey) return EMPTY_PROMISE;\n      if (shouldRevalidate) {\n        if (!isUndefined(data)) {\n          // We only revalidate the pages that are changed\n          set({\n            _i: false\n          });\n        } else {\n          // Calling `mutate()`, we revalidate all pages\n          set({\n            _i: true\n          });\n        }\n      }\n      return arguments.length ? swr.mutate(data, _objectSpread(_objectSpread({}, options), {}, {\n        revalidate: shouldRevalidate\n      })) : swr.mutate();\n    },\n    // swr.mutate is always the same reference\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [infiniteKey, cache]);\n    // Extend the SWR API\n    var setSize = useCallback(function (arg) {\n      // It is possible that the key is still falsy.\n      if (!infiniteKey) return EMPTY_PROMISE;\n      var _createCacheHelper7 = createCacheHelper(cache, infiniteKey),\n        _createCacheHelper8 = _slicedToArray(_createCacheHelper7, 2),\n        changeSize = _createCacheHelper8[1];\n      var size;\n      if (isFunction(arg)) {\n        size = arg(resolvePageSize());\n      } else if (typeof arg == 'number') {\n        size = arg;\n      }\n      if (typeof size != 'number') return EMPTY_PROMISE;\n      changeSize({\n        _l: size\n      });\n      lastPageSizeRef.current = size;\n      // Calculate the page data after the size change.\n      var data = [];\n      var _createCacheHelper9 = createCacheHelper(cache, infiniteKey),\n        _createCacheHelper10 = _slicedToArray(_createCacheHelper9, 1),\n        getInfiniteCache = _createCacheHelper10[0];\n      var previousPageData = null;\n      for (var i = 0; i < size; ++i) {\n        var _serialize3 = serialize(getKey(i, previousPageData)),\n          _serialize4 = _slicedToArray(_serialize3, 1),\n          pageKey = _serialize4[0];\n        var _createCacheHelper11 = createCacheHelper(cache, pageKey),\n          _createCacheHelper12 = _slicedToArray(_createCacheHelper11, 1),\n          getCache = _createCacheHelper12[0];\n        // Get the cached page data.\n        var pageData = pageKey ? getCache().data : UNDEFINED;\n        // Call `mutate` with infinte cache data if we can't get it from the page cache.\n        if (isUndefined(pageData)) {\n          return mutate(getInfiniteCache().data);\n        }\n        data.push(pageData);\n        previousPageData = pageData;\n      }\n      return mutate(data);\n    },\n    // exclude getKey from the dependencies, which isn't allowed to change during the lifecycle\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [infiniteKey, cache, mutate, resolvePageSize]);\n    // Use getter functions to avoid unnecessary re-renders caused by triggering\n    // all the getters of the returned swr object.\n    return {\n      size: resolvePageSize(),\n      setSize: setSize,\n      mutate: mutate,\n      get data() {\n        return swr.data;\n      },\n      get error() {\n        return swr.error;\n      },\n      get isValidating() {\n        return swr.isValidating;\n      },\n      get isLoading() {\n        return swr.isLoading;\n      }\n    };\n  };\n};\nvar index = withMiddleware(useSWR, infinite);\nexport { index as default, infinite, unstable_serialize };","map":{"version":3,"names":["useRef","useCallback","useSWR","withMiddleware","createCacheHelper","isUndefined","useIsomorphicLayoutEffect","serialize","UNDEFINED","isFunction","useSyncExternalStore","INFINITE_PREFIX","EMPTY_PROMISE","Promise","resolve","getFirstPageKey","getKey","unstable_serialize","infinite","useSWRNext","fn","config","didMountRef","cache","_config$initialSize","initialSize","_config$revalidateAll","revalidateAll","_config$persistSize","persistSize","_config$revalidateFir","revalidateFirstPage","_config$revalidateOnM","revalidateOnMount","_config$parallel","parallel","infiniteKey","err","_createCacheHelper","_createCacheHelper2","_slicedToArray","get","set","subscribeCache","getSnapshot","size","_l","callback","resolvePageSize","cachedPageSize","lastPageSizeRef","current","shouldRevalidateOnMount","swr","_ref","_asyncToGenerator","_regeneratorRuntime","mark","_callee2","key","forceRevalidateAll","data","pageSize","_createCacheHelper3","_createCacheHelper4","getCache","cacheData","revalidators","previousPageData","_loop","i","_ret","wrap","_callee2$","_context3","prev","next","_i","_serialize","_serialize2","pageKey","pageArg","_createCacheHelper5","_createCacheHelper6","getSWRCache","setSWRCache","pageData","shouldFetchPage","revalidate","_loop$","_context2","abrupt","compare","_ref2","_callee","_callee$","_context","sent","_k","stop","apply","arguments","push","delegateYield","t0","all","map","r","_x","mutate","opts","options","shouldRevalidate","length","_objectSpread","setSize","arg","_createCacheHelper7","_createCacheHelper8","changeSize","_createCacheHelper9","_createCacheHelper10","getInfiniteCache","_serialize3","_serialize4","_createCacheHelper11","_createCacheHelper12","error","isValidating","isLoading","index","default"],"sources":["/Users/behzad/Desktop/swr/node_modules/swr/infinite/dist/index.mjs"],"sourcesContent":["import { useRef, useCallback } from 'react';\nimport useSWR from 'swr';\nimport { withMiddleware, createCacheHelper, isUndefined, useIsomorphicLayoutEffect, serialize, UNDEFINED, isFunction } from 'swr/_internal';\nimport { useSyncExternalStore } from 'use-sync-external-store/shim/index.js';\n\n// We have to several type castings here because `useSWRInfinite` is a special\nconst INFINITE_PREFIX = '$inf$';\nconst EMPTY_PROMISE = Promise.resolve();\nconst getFirstPageKey = (getKey)=>{\n    return serialize(getKey ? getKey(0, null) : null)[0];\n};\nconst unstable_serialize = (getKey)=>{\n    return INFINITE_PREFIX + getFirstPageKey(getKey);\n};\nconst infinite = (useSWRNext)=>(getKey, fn, config)=>{\n        const didMountRef = useRef(false);\n        const { cache , initialSize =1 , revalidateAll =false , persistSize =false , revalidateFirstPage =true , revalidateOnMount =false , parallel =false  } = config;\n        // The serialized key of the first page. This key will be used to store\n        // metadata of this SWR infinite hook.\n        let infiniteKey;\n        try {\n            infiniteKey = getFirstPageKey(getKey);\n            if (infiniteKey) infiniteKey = INFINITE_PREFIX + infiniteKey;\n        } catch (err) {\n        // Not ready yet.\n        }\n        const [get, set, subscribeCache] = createCacheHelper(cache, infiniteKey);\n        const getSnapshot = useCallback(()=>{\n            const size = isUndefined(get()._l) ? initialSize : get()._l;\n            return size;\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n        }, [\n            cache,\n            infiniteKey,\n            initialSize\n        ]);\n        useSyncExternalStore(useCallback((callback)=>{\n            if (infiniteKey) return subscribeCache(infiniteKey, ()=>{\n                callback();\n            });\n            return ()=>{};\n        }, // eslint-disable-next-line react-hooks/exhaustive-deps\n        [\n            cache,\n            infiniteKey\n        ]), getSnapshot, getSnapshot);\n        const resolvePageSize = useCallback(()=>{\n            const cachedPageSize = get()._l;\n            return isUndefined(cachedPageSize) ? initialSize : cachedPageSize;\n        // `cache` isn't allowed to change during the lifecycle\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n        }, [\n            infiniteKey,\n            initialSize\n        ]);\n        // keep the last page size to restore it with the persistSize option\n        const lastPageSizeRef = useRef(resolvePageSize());\n        // When the page key changes, we reset the page size if it's not persisted\n        useIsomorphicLayoutEffect(()=>{\n            if (!didMountRef.current) {\n                didMountRef.current = true;\n                return;\n            }\n            if (infiniteKey) {\n                // If the key has been changed, we keep the current page size if persistSize is enabled\n                // Otherwise, we reset the page size to cached pageSize\n                set({\n                    _l: persistSize ? lastPageSizeRef.current : resolvePageSize()\n                });\n            }\n        // `initialSize` isn't allowed to change during the lifecycle\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n        }, [\n            infiniteKey,\n            cache\n        ]);\n        // Needs to check didMountRef during mounting, not in the fetcher\n        const shouldRevalidateOnMount = revalidateOnMount && !didMountRef.current;\n        // Actual SWR hook to load all pages in one fetcher.\n        const swr = useSWRNext(infiniteKey, async (key)=>{\n            // get the revalidate context\n            const forceRevalidateAll = get()._i;\n            // return an array of page data\n            const data = [];\n            const pageSize = resolvePageSize();\n            const [getCache] = createCacheHelper(cache, key);\n            const cacheData = getCache().data;\n            const revalidators = [];\n            let previousPageData = null;\n            for(let i = 0; i < pageSize; ++i){\n                const [pageKey, pageArg] = serialize(getKey(i, parallel ? null : previousPageData));\n                if (!pageKey) {\n                    break;\n                }\n                const [getSWRCache, setSWRCache] = createCacheHelper(cache, pageKey);\n                // Get the cached page data.\n                let pageData = getSWRCache().data;\n                // should fetch (or revalidate) if:\n                // - `revalidateAll` is enabled\n                // - `mutate()` called\n                // - the cache is missing\n                // - it's the first page and it's not the initial render\n                // - `revalidateOnMount` is enabled and it's on mount\n                // - cache for that page has changed\n                const shouldFetchPage = revalidateAll || forceRevalidateAll || isUndefined(pageData) || revalidateFirstPage && !i && !isUndefined(cacheData) || shouldRevalidateOnMount || cacheData && !isUndefined(cacheData[i]) && !config.compare(cacheData[i], pageData);\n                if (fn && shouldFetchPage) {\n                    const revalidate = async ()=>{\n                        pageData = await fn(pageArg);\n                        setSWRCache({\n                            data: pageData,\n                            _k: pageArg\n                        });\n                        data[i] = pageData;\n                    };\n                    if (parallel) {\n                        revalidators.push(revalidate);\n                    } else {\n                        await revalidate();\n                    }\n                } else {\n                    data[i] = pageData;\n                }\n                if (!parallel) {\n                    previousPageData = pageData;\n                }\n            }\n            // flush all revalidateions in parallel\n            if (parallel) {\n                await Promise.all(revalidators.map((r)=>r()));\n            }\n            // once we executed the data fetching based on the context, clear the context\n            set({\n                _i: UNDEFINED\n            });\n            // return the data\n            return data;\n        }, config);\n        const mutate = useCallback(// eslint-disable-next-line func-names\n        function(data, opts) {\n            // When passing as a boolean, it's explicitly used to disable/enable\n            // revalidation.\n            const options = typeof opts === 'boolean' ? {\n                revalidate: opts\n            } : opts || {};\n            // Default to true.\n            const shouldRevalidate = options.revalidate !== false;\n            // It is possible that the key is still falsy.\n            if (!infiniteKey) return EMPTY_PROMISE;\n            if (shouldRevalidate) {\n                if (!isUndefined(data)) {\n                    // We only revalidate the pages that are changed\n                    set({\n                        _i: false\n                    });\n                } else {\n                    // Calling `mutate()`, we revalidate all pages\n                    set({\n                        _i: true\n                    });\n                }\n            }\n            return arguments.length ? swr.mutate(data, {\n                ...options,\n                revalidate: shouldRevalidate\n            }) : swr.mutate();\n        }, // swr.mutate is always the same reference\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n        [\n            infiniteKey,\n            cache\n        ]);\n        // Extend the SWR API\n        const setSize = useCallback((arg)=>{\n            // It is possible that the key is still falsy.\n            if (!infiniteKey) return EMPTY_PROMISE;\n            const [, changeSize] = createCacheHelper(cache, infiniteKey);\n            let size;\n            if (isFunction(arg)) {\n                size = arg(resolvePageSize());\n            } else if (typeof arg == 'number') {\n                size = arg;\n            }\n            if (typeof size != 'number') return EMPTY_PROMISE;\n            changeSize({\n                _l: size\n            });\n            lastPageSizeRef.current = size;\n            // Calculate the page data after the size change.\n            const data = [];\n            const [getInfiniteCache] = createCacheHelper(cache, infiniteKey);\n            let previousPageData = null;\n            for(let i = 0; i < size; ++i){\n                const [pageKey] = serialize(getKey(i, previousPageData));\n                const [getCache] = createCacheHelper(cache, pageKey);\n                // Get the cached page data.\n                const pageData = pageKey ? getCache().data : UNDEFINED;\n                // Call `mutate` with infinte cache data if we can't get it from the page cache.\n                if (isUndefined(pageData)) {\n                    return mutate(getInfiniteCache().data);\n                }\n                data.push(pageData);\n                previousPageData = pageData;\n            }\n            return mutate(data);\n        }, // exclude getKey from the dependencies, which isn't allowed to change during the lifecycle\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n        [\n            infiniteKey,\n            cache,\n            mutate,\n            resolvePageSize\n        ]);\n        // Use getter functions to avoid unnecessary re-renders caused by triggering\n        // all the getters of the returned swr object.\n        return {\n            size: resolvePageSize(),\n            setSize,\n            mutate,\n            get data () {\n                return swr.data;\n            },\n            get error () {\n                return swr.error;\n            },\n            get isValidating () {\n                return swr.isValidating;\n            },\n            get isLoading () {\n                return swr.isLoading;\n            }\n        };\n    };\nvar index = withMiddleware(useSWR, infinite);\n\nexport { index as default, infinite, unstable_serialize };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}