{"ast":null,"code":"import React, { forwardRef, useRef, useState, useEffect } from \"react\";\nconst isArray = thing => Array.isArray(thing);\nconst asArray = value => {\n  return isArray(value) ? value : [value];\n};\nlet Queue = function (initialItems) {\n  let add = function (steps) {\n    asArray(steps).forEach(step => {\n      var _a;\n      return _q.set(Symbol((_a = step.char) == null ? void 0 : _a.innerText), buildQueueItem({\n        ...step\n      }));\n    });\n    return this;\n  };\n  let getTypeable = () => rawValues().filter(value => value.typeable);\n  let set = function (index, item) {\n    let keys = [..._q.keys()];\n    _q.set(keys[index], buildQueueItem(item));\n  };\n  let buildQueueItem = queueItem => {\n    queueItem.shouldPauseCursor = function () {\n      return Boolean(this.typeable || this.cursorable || this.deletable);\n    };\n    return queueItem;\n  };\n  let reset = function () {\n    _q.forEach(item => delete item.done);\n  };\n  let wipe = function () {\n    _q = /* @__PURE__ */new Map();\n    add(initialItems);\n  };\n  let getQueue = () => _q;\n  let rawValues = () => Array.from(_q.values());\n  let destroy = key => _q.delete(key);\n  let getItems = function () {\n    let all = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    return all ? rawValues() : rawValues().filter(i => !i.done);\n  };\n  let done = function (key) {\n    let shouldDestroy = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    return shouldDestroy ? _q.delete(key) : _q.get(key).done = true;\n  };\n  let _q = /* @__PURE__ */new Map();\n  add(initialItems);\n  return {\n    add,\n    set,\n    wipe,\n    reset,\n    destroy,\n    done,\n    getItems,\n    getQueue,\n    getTypeable\n  };\n};\nconst toArray = val => Array.from(val);\nconst createTextNode = content => document.createTextNode(content);\nlet expandTextNodes = element => {\n  [...element.childNodes].forEach(child => {\n    if (child.nodeValue) {\n      [...child.nodeValue].forEach(c => {\n        child.parentNode.insertBefore(createTextNode(c), child);\n      });\n      child.remove();\n      return;\n    }\n    expandTextNodes(child);\n  });\n  return element;\n};\nconst getParsedBody = content => {\n  let doc = document.implementation.createHTMLDocument();\n  doc.body.innerHTML = content;\n  return expandTextNodes(doc.body);\n};\nconst DATA_ATTRIBUTE = \"data-typeit-id\";\nconst CURSOR_CLASS = \"ti-cursor\";\nconst END = \"END\";\nconst DEFAULT_STATUSES = {\n  started: false,\n  completed: false,\n  frozen: false,\n  destroyed: false\n};\nconst DEFAULT_OPTIONS = {\n  breakLines: true,\n  cursor: {\n    autoPause: true,\n    autoPauseDelay: 500,\n    animation: {\n      frames: [0, 0, 1].map(n => {\n        return {\n          opacity: n\n        };\n      }),\n      options: {\n        iterations: Infinity,\n        easing: \"steps(2, start)\",\n        fill: \"forwards\"\n      }\n    }\n  },\n  cursorChar: \"|\",\n  cursorSpeed: 1e3,\n  deleteSpeed: null,\n  html: true,\n  lifeLike: true,\n  loop: false,\n  loopDelay: 750,\n  nextStringDelay: 750,\n  speed: 100,\n  startDelay: 250,\n  startDelete: false,\n  strings: [],\n  waitUntilVisible: false,\n  beforeString: () => {},\n  afterString: () => {},\n  beforeStep: () => {},\n  afterStep: () => {},\n  afterComplete: () => {}\n};\nconst PLACEHOLDER_CSS = `[${DATA_ATTRIBUTE}]:before {content: '.'; display: inline-block; width: 0; visibility: hidden;}`;\nfunction walkElementNodes(element) {\n  let shouldReverse = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  let shouldIncludeCursor = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  let cursor = element.querySelector(`.${CURSOR_CLASS}`);\n  let walker = document.createTreeWalker(element, NodeFilter.SHOW_ALL, {\n    acceptNode: node => {\n      var _a, _b;\n      if (cursor && shouldIncludeCursor) {\n        if ((_a = node.classList) == null ? void 0 : _a.contains(CURSOR_CLASS)) {\n          return NodeFilter.FILTER_ACCEPT;\n        }\n        if (cursor.contains(node)) {\n          return NodeFilter.FILTER_REJECT;\n        }\n      }\n      return ((_b = node.classList) == null ? void 0 : _b.contains(CURSOR_CLASS)) ? NodeFilter.FILTER_REJECT : NodeFilter.FILTER_ACCEPT;\n    }\n  });\n  let nextNode;\n  let nodes = [];\n  while (nextNode = walker.nextNode()) {\n    if (!nextNode.originalParent) {\n      nextNode.originalParent = nextNode.parentNode;\n    }\n    nodes.push(nextNode);\n  }\n  return shouldReverse ? nodes.reverse() : nodes;\n}\nfunction chunkStringAsHtml(string) {\n  return walkElementNodes(getParsedBody(string));\n}\nfunction maybeChunkStringAsHtml(str) {\n  let asHtml = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n  return asHtml ? chunkStringAsHtml(str) : toArray(str).map(createTextNode);\n}\nconst createElement = el => document.createElement(el);\nconst appendStyleBlock = function (styles) {\n  let id = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n  let styleBlock = createElement(\"style\");\n  styleBlock.id = id;\n  styleBlock.appendChild(createTextNode(styles));\n  document.head.appendChild(styleBlock);\n};\nconst calculateDelay = delayArg => {\n  if (!isArray(delayArg)) {\n    delayArg = [delayArg / 2, delayArg / 2];\n  }\n  return delayArg;\n};\nconst randomInRange = (value, range2) => {\n  return Math.abs(Math.random() * (value + range2 - (value - range2)) + (value - range2));\n};\nlet range = val => val / 2;\nfunction calculatePace(options) {\n  let {\n    speed,\n    deleteSpeed,\n    lifeLike\n  } = options;\n  deleteSpeed = deleteSpeed !== null ? deleteSpeed : speed / 3;\n  return lifeLike ? [randomInRange(speed, range(speed)), randomInRange(deleteSpeed, range(deleteSpeed))] : [speed, deleteSpeed];\n}\nconst destroyTimeouts = timeouts => {\n  timeouts.forEach(clearTimeout);\n  return [];\n};\nconst generateHash = () => Math.random().toString().substring(2, 9);\nconst isInput = el => \"value\" in el;\nlet getAllChars = element => {\n  if (isInput(element)) {\n    return toArray(element.value);\n  }\n  return walkElementNodes(element, true).filter(c => !(c.childNodes.length > 0));\n};\nconst fireWhenVisible = (element, func) => {\n  let observer = new IntersectionObserver((entries, observer2) => {\n    entries.forEach(entry => {\n      if (entry.isIntersecting) {\n        func();\n        observer2.unobserve(element);\n      }\n    });\n  }, {\n    threshold: 1\n  });\n  observer.observe(element);\n};\nlet handleFunctionalArg = arg => {\n  return typeof arg === \"function\" ? arg() : arg;\n};\nconst isNumber = value => Number.isInteger(value);\nlet select = function (selector) {\n  let element = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : document;\n  let all = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  return element[`querySelector${all ? \"All\" : \"\"}`](selector);\n};\nlet isBodyElement = node => /body/i.test(node == null ? void 0 : node.tagName);\nlet insertIntoElement = (originalTarget, character) => {\n  if (isInput(originalTarget)) {\n    originalTarget.value = `${originalTarget.value}${character.textContent}`;\n    return;\n  }\n  character.innerHTML = \"\";\n  let target = isBodyElement(character.originalParent) ? originalTarget : character.originalParent || originalTarget;\n  target.insertBefore(character, select(\".\" + CURSOR_CLASS, target) || null);\n};\nlet updateCursorPosition = (steps, cursorPosition, printedCharacters) => {\n  return Math.min(Math.max(cursorPosition + steps, 0), printedCharacters.length);\n};\nconst merge = (originalObj, newObj) => Object.assign({}, originalObj, newObj);\nconst removeNode = (node, rootElement) => {\n  if (!node) return;\n  let nodeParent = node.parentNode;\n  let nodeToRemove = nodeParent.childNodes.length > 1 || nodeParent.isSameNode(rootElement) ? node : nodeParent;\n  nodeToRemove.remove();\n};\nconst repositionCursor = (element, allChars, newCursorPosition) => {\n  let nodeToInsertBefore = allChars[newCursorPosition - 1];\n  let cursor = select(`.${CURSOR_CLASS}`, element);\n  element = (nodeToInsertBefore == null ? void 0 : nodeToInsertBefore.parentNode) || element;\n  element.insertBefore(cursor, nodeToInsertBefore || null);\n};\nfunction selectorToElement(thing) {\n  return typeof thing === \"string\" ? select(thing) : thing;\n}\nconst isNonVoidElement = el => /<(.+)>(.*?)<\\/(.+)>/.test(el.outerHTML);\nlet wait = (callback, delay, timeouts) => {\n  return new Promise(resolve => {\n    let cb = async () => {\n      await callback();\n      resolve();\n    };\n    timeouts.push(setTimeout(cb, delay || 0));\n  });\n};\nlet cursorFontStyles = {\n  \"font-family\": \"\",\n  \"font-weight\": \"\",\n  \"font-size\": \"\",\n  \"font-style\": \"\",\n  \"line-height\": \"\",\n  color: \"\",\n  transform: \"translateX(-.125em)\"\n};\nlet setCursorStyles = (id, element) => {\n  let rootSelector = `[${DATA_ATTRIBUTE}='${id}']`;\n  let cursorSelector = `${rootSelector} .${CURSOR_CLASS}`;\n  let computedStyles = getComputedStyle(element);\n  let customProperties = Object.entries(cursorFontStyles).reduce((accumulator, _ref) => {\n    let [item, value] = _ref;\n    return `${accumulator} ${item}: var(--ti-cursor-${item}, ${value || computedStyles[item]});`;\n  }, \"\");\n  appendStyleBlock(`${cursorSelector} { display: inline-block; width: 0; ${customProperties} }`, id);\n};\nconst duplicate = (value, times) => new Array(times).fill(value);\nconst countStepsToSelector = _ref2 => {\n  let {\n    queueItems,\n    selector,\n    cursorPosition,\n    to\n  } = _ref2;\n  if (isNumber(selector)) {\n    return selector * -1;\n  }\n  let isMovingToEnd = new RegExp(END, \"i\").test(to);\n  let selectorIndex = selector ? [...queueItems].reverse().findIndex(_ref3 => {\n    let {\n      char\n    } = _ref3;\n    let parentElement = char.parentElement;\n    let parentMatches = parentElement.matches(selector);\n    if (isMovingToEnd && parentMatches) {\n      return true;\n    }\n    return parentMatches && parentElement.firstChild.isSameNode(char);\n  }) : -1;\n  if (selectorIndex < 0) {\n    selectorIndex = isMovingToEnd ? 0 : queueItems.length - 1;\n  }\n  let offset = isMovingToEnd ? 0 : 1;\n  return selectorIndex - cursorPosition + offset;\n};\nlet beforePaint = cb => {\n  return new Promise(resolve => {\n    requestAnimationFrame(async () => {\n      resolve(await cb());\n    });\n  });\n};\nlet getAnimationFromElement = element => {\n  return element == null ? void 0 : element.getAnimations().find(animation => {\n    return animation.id === element.dataset.tiAnimationId;\n  });\n};\nlet setCursorAnimation = _ref4 => {\n  let {\n    cursor,\n    frames,\n    options\n  } = _ref4;\n  let animation = cursor.animate(frames, options);\n  animation.pause();\n  animation.id = cursor.dataset.tiAnimationId;\n  beforePaint(() => {\n    beforePaint(() => {\n      animation.play();\n    });\n  });\n  return animation;\n};\nlet rebuildCursorAnimation = _ref5 => {\n  let {\n    cursor,\n    options,\n    cursorOptions\n  } = _ref5;\n  if (!cursor || !cursorOptions) return;\n  let animation = getAnimationFromElement(cursor);\n  let oldCurrentTime;\n  if (animation) {\n    options.delay = animation.effect.getComputedTiming().delay;\n    oldCurrentTime = animation.currentTime;\n    animation.cancel();\n  }\n  let newAnimation = setCursorAnimation({\n    cursor,\n    frames: cursorOptions.animation.frames,\n    options\n  });\n  if (oldCurrentTime) {\n    newAnimation.currentTime = oldCurrentTime;\n  }\n  return newAnimation;\n};\nlet execute = queueItem => {\n  var _a;\n  return (_a = queueItem.func) == null ? void 0 : _a.call(null);\n};\nlet fireItem = async _ref6 => {\n  let {\n    index,\n    queueItems,\n    wait: wait2,\n    cursor,\n    cursorOptions\n  } = _ref6;\n  let queueItem = queueItems[index][1];\n  let instantQueue = [];\n  let tempIndex = index;\n  let futureItem = queueItem;\n  let shouldBeGrouped = () => futureItem && !futureItem.delay;\n  let shouldPauseCursor = queueItem.shouldPauseCursor() && cursorOptions.autoPause;\n  while (shouldBeGrouped()) {\n    instantQueue.push(futureItem);\n    shouldBeGrouped() && tempIndex++;\n    futureItem = queueItems[tempIndex] ? queueItems[tempIndex][1] : null;\n  }\n  if (instantQueue.length) {\n    await beforePaint(async () => {\n      for (let q of instantQueue) {\n        await execute(q);\n      }\n    });\n    return tempIndex - 1;\n  }\n  let animation = getAnimationFromElement(cursor);\n  let options;\n  if (animation) {\n    options = {\n      ...animation.effect.getComputedTiming(),\n      delay: shouldPauseCursor ? cursorOptions.autoPauseDelay : 0\n    };\n  }\n  await wait2(async () => {\n    if (animation && shouldPauseCursor) {\n      animation.cancel();\n    }\n    await beforePaint(() => {\n      execute(queueItem);\n    });\n  }, queueItem.delay);\n  await rebuildCursorAnimation({\n    cursor,\n    options,\n    cursorOptions\n  });\n  return index;\n};\nlet processCursorOptions = cursorOptions => {\n  var _a, _b;\n  if (typeof cursorOptions === \"object\") {\n    let newOptions = {};\n    let {\n      frames: defaultFrames,\n      options: defaultOptions\n    } = DEFAULT_OPTIONS.cursor.animation;\n    newOptions.animation = cursorOptions.animation || {};\n    newOptions.animation.frames = ((_a = cursorOptions.animation) == null ? void 0 : _a.frames) || defaultFrames;\n    newOptions.animation.options = merge(defaultOptions, ((_b = cursorOptions.animation) == null ? void 0 : _b.options) || {});\n    newOptions.autoPause = cursorOptions.autoPause ?? DEFAULT_OPTIONS.cursor.autoPause;\n    newOptions.autoPauseDelay = cursorOptions.autoPauseDelay || DEFAULT_OPTIONS.cursor.autoPauseDelay;\n    return newOptions;\n  }\n  if (cursorOptions === true) {\n    return DEFAULT_OPTIONS.cursor;\n  }\n  return cursorOptions;\n};\nconst TypeIt$1 = function (element) {\n  var _this = this;\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let _wait = async function (callback, delay) {\n    let silent = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    if (_statuses.frozen) {\n      await new Promise(resolve => {\n        _this.unfreeze = () => {\n          _statuses.frozen = false;\n          resolve();\n        };\n      });\n    }\n    silent || (await _opts.beforeStep(_this));\n    await wait(callback, delay, _timeouts);\n    silent || (await _opts.afterStep(_this));\n  };\n  let _fireItemWithContext = (index, queueItems) => {\n    return fireItem({\n      index,\n      queueItems,\n      wait: _wait,\n      cursor: _cursor,\n      cursorOptions: _opts.cursor\n    });\n  };\n  let _removeNode = node => removeNode(node, _element);\n  let _elementIsInput = () => isInput(_element);\n  let _getPace = function () {\n    let index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    return calculatePace(_opts)[index];\n  };\n  let _getAllChars = () => getAllChars(_element);\n  let _maybeAppendPause = function () {\n    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let delay = opts.delay;\n    delay && _queue.add({\n      delay\n    });\n  };\n  let _queueAndReturn = (steps, opts) => {\n    _queue.add(steps);\n    _maybeAppendPause(opts);\n    return this;\n  };\n  let _getDerivedCursorPosition = () => _predictedCursorPosition ?? _cursorPosition;\n  let _generateTemporaryOptionQueueItems = function () {\n    let newOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return [{\n      func: () => _options(newOptions)\n    }, {\n      func: () => _options(_opts)\n    }];\n  };\n  let _addSplitPause = items => {\n    let delay = _opts.nextStringDelay;\n    _queue.add([{\n      delay: delay[0]\n    }, ...items, {\n      delay: delay[1]\n    }]);\n  };\n  let _setUpCursor = () => {\n    if (_elementIsInput()) {\n      return;\n    }\n    let cursor = createElement(\"span\");\n    cursor.className = CURSOR_CLASS;\n    if (!_shouldRenderCursor) {\n      cursor.style.visibility = \"hidden\";\n      return cursor;\n    }\n    cursor.innerHTML = getParsedBody(_opts.cursorChar).innerHTML;\n    return cursor;\n  };\n  let _attachCursor = async () => {\n    !_elementIsInput() && _cursor && _element.appendChild(_cursor);\n    if (_shouldRenderCursor) {\n      setCursorStyles(_id, _element);\n      _cursor.dataset.tiAnimationId = _id;\n      let {\n        animation\n      } = _opts.cursor;\n      let {\n        frames,\n        options: options2\n      } = animation;\n      setCursorAnimation({\n        frames,\n        cursor: _cursor,\n        options: {\n          duration: _opts.cursorSpeed,\n          ...options2\n        }\n      });\n    }\n  };\n  let _generateQueue = () => {\n    let strings = _opts.strings.filter(string => !!string);\n    strings.forEach((string, index) => {\n      this.type(string);\n      if (index + 1 === strings.length) {\n        return;\n      }\n      let splitItems = _opts.breakLines ? [{\n        func: () => _type(createElement(\"BR\")),\n        typeable: true\n      }] : duplicate({\n        func: _delete,\n        delay: _getPace(1)\n      }, _queue.getTypeable().length);\n      _addSplitPause(splitItems);\n    });\n  };\n  let _prepLoop = async delay => {\n    let derivedCursorPosition = _getDerivedCursorPosition();\n    derivedCursorPosition && (await _move({\n      value: derivedCursorPosition\n    }));\n    let queueItems = _getAllChars().map(c => {\n      return [Symbol(), {\n        func: _delete,\n        delay: _getPace(1),\n        deletable: true,\n        shouldPauseCursor: () => true\n      }];\n    });\n    for (let index = 0; index < queueItems.length; index++) {\n      await _fireItemWithContext(index, queueItems);\n    }\n    _queue.reset();\n    _queue.set(0, {\n      delay\n    });\n  };\n  let _maybePrependHardcodedStrings = strings => {\n    let existingMarkup = _element.innerHTML;\n    if (!existingMarkup) {\n      return strings;\n    }\n    _element.innerHTML = \"\";\n    if (_opts.startDelete) {\n      _element.innerHTML = existingMarkup;\n      expandTextNodes(_element);\n      _addSplitPause(duplicate({\n        func: _delete,\n        delay: _getPace(1),\n        deletable: true\n      }, _getAllChars().length));\n      return strings;\n    }\n    let hardCodedStrings = existingMarkup.replace(/<!--(.+?)-->/g, \"\").trim().split(/<br(?:\\s*?)(?:\\/)?>/);\n    return hardCodedStrings.concat(strings);\n  };\n  let _fire = async function () {\n    let remember = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    _statuses.started = true;\n    let cleanUp = qKey => {\n      _queue.done(qKey, !remember);\n    };\n    try {\n      let queueItems = [..._queue.getQueue()];\n      for (let index = 0; index < queueItems.length; index++) {\n        let [queueKey, queueItem] = queueItems[index];\n        if (queueItem.done) continue;\n        if (!queueItem.deletable || queueItem.deletable && _getAllChars().length) {\n          let newIndex = await _fireItemWithContext(index, queueItems);\n          Array(newIndex - index).fill(index + 1).map((x, y) => x + y).forEach(i => {\n            let [key] = queueItems[i];\n            cleanUp(key);\n          });\n          index = newIndex;\n        }\n        cleanUp(queueKey);\n      }\n      if (!remember) {\n        return _this;\n      }\n      _statuses.completed = true;\n      await _opts.afterComplete(_this);\n      if (!_opts.loop) {\n        throw \"\";\n      }\n      let delay = _opts.loopDelay;\n      _wait(async () => {\n        await _prepLoop(delay[0]);\n        _fire();\n      }, delay[1]);\n    } catch (e) {}\n    return _this;\n  };\n  let _move = async step => {\n    _cursorPosition = updateCursorPosition(step, _cursorPosition, _getAllChars());\n    repositionCursor(_element, _getAllChars(), _cursorPosition);\n  };\n  let _type = char => insertIntoElement(_element, char);\n  let _options = async opts => _opts = merge(_opts, opts);\n  let _empty = async () => {\n    if (_elementIsInput()) {\n      _element.value = \"\";\n      return;\n    }\n    _getAllChars().forEach(_removeNode);\n    return;\n  };\n  let _delete = () => {\n    let allChars = _getAllChars();\n    if (!allChars.length) return;\n    if (_elementIsInput()) {\n      _element.value = _element.value.slice(0, -1);\n    } else {\n      _removeNode(allChars[_cursorPosition]);\n    }\n  };\n  this.break = function (actionOpts) {\n    return _queueAndReturn({\n      func: () => _type(createElement(\"BR\")),\n      typeable: true\n    }, actionOpts);\n  };\n  this.delete = function () {\n    let numCharacters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    let actionOpts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    numCharacters = handleFunctionalArg(numCharacters);\n    let bookEndQueueItems = _generateTemporaryOptionQueueItems(actionOpts);\n    let num = numCharacters;\n    let {\n      instant,\n      to\n    } = actionOpts;\n    let typeableQueueItems = _queue.getTypeable();\n    let rounds = (() => {\n      if (num === null) {\n        return typeableQueueItems.length;\n      }\n      if (isNumber(num)) {\n        return num;\n      }\n      return countStepsToSelector({\n        queueItems: typeableQueueItems,\n        selector: num,\n        cursorPosition: _getDerivedCursorPosition(),\n        to\n      });\n    })();\n    return _queueAndReturn([bookEndQueueItems[0], ...duplicate({\n      func: _delete,\n      delay: instant ? 0 : _getPace(1),\n      deletable: true\n    }, rounds), bookEndQueueItems[1]], actionOpts);\n  };\n  this.empty = function () {\n    let actionOpts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return _queueAndReturn({\n      func: _empty\n    }, actionOpts);\n  };\n  this.exec = function (func) {\n    let actionOpts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let bookEndQueueItems = _generateTemporaryOptionQueueItems(actionOpts);\n    return _queueAndReturn([bookEndQueueItems[0], {\n      func: () => func(this)\n    }, bookEndQueueItems[1]], actionOpts);\n  };\n  this.move = function (movementArg) {\n    let actionOpts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    movementArg = handleFunctionalArg(movementArg);\n    let bookEndQueueItems = _generateTemporaryOptionQueueItems(actionOpts);\n    let {\n      instant,\n      to\n    } = actionOpts;\n    let numberOfSteps = countStepsToSelector({\n      queueItems: _queue.getTypeable(),\n      selector: movementArg === null ? \"\" : movementArg,\n      to,\n      cursorPosition: _getDerivedCursorPosition()\n    });\n    let directionalStep = numberOfSteps < 0 ? -1 : 1;\n    _predictedCursorPosition = _getDerivedCursorPosition() + numberOfSteps;\n    return _queueAndReturn([bookEndQueueItems[0], ...duplicate({\n      func: () => _move(directionalStep),\n      delay: instant ? 0 : _getPace(),\n      cursorable: true\n    }, Math.abs(numberOfSteps)), bookEndQueueItems[1]], actionOpts);\n  };\n  this.options = function (opts) {\n    let actionOpts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    opts = handleFunctionalArg(opts);\n    _options(opts);\n    return _queueAndReturn({}, actionOpts);\n  };\n  this.pause = function (milliseconds) {\n    let actionOpts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return _queueAndReturn({\n      delay: handleFunctionalArg(milliseconds)\n    }, actionOpts);\n  };\n  this.type = function (string) {\n    let actionOpts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    string = handleFunctionalArg(string);\n    let {\n      instant\n    } = actionOpts;\n    let bookEndQueueItems = _generateTemporaryOptionQueueItems(actionOpts);\n    let chars = maybeChunkStringAsHtml(string, _opts.html);\n    let charsAsQueueItems = chars.map(char => {\n      return {\n        func: () => _type(char),\n        char,\n        delay: instant || isNonVoidElement(char) ? 0 : _getPace(),\n        typeable: char.nodeType === Node.TEXT_NODE\n      };\n    });\n    let itemsToQueue = [bookEndQueueItems[0], {\n      func: async () => await _opts.beforeString(string, this)\n    }, ...charsAsQueueItems, {\n      func: async () => await _opts.afterString(string, this)\n    }, bookEndQueueItems[1]];\n    return _queueAndReturn(itemsToQueue, actionOpts);\n  };\n  this.is = function (key) {\n    return _statuses[key];\n  };\n  this.destroy = function () {\n    let shouldRemoveCursor = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    _timeouts = destroyTimeouts(_timeouts);\n    handleFunctionalArg(shouldRemoveCursor) && _cursor && _removeNode(_cursor);\n    _statuses.destroyed = true;\n  };\n  this.freeze = function () {\n    _statuses.frozen = true;\n  };\n  this.unfreeze = () => {};\n  this.reset = function (rebuild) {\n    !this.is(\"destroyed\") && this.destroy();\n    if (rebuild) {\n      _queue.wipe();\n      rebuild(this);\n    } else {\n      _queue.reset();\n    }\n    _cursorPosition = 0;\n    for (let property in _statuses) {\n      _statuses[property] = false;\n    }\n    _element[_elementIsInput() ? \"value\" : \"innerHTML\"] = \"\";\n    return this;\n  };\n  this.go = function () {\n    if (_statuses.started) {\n      return this;\n    }\n    _attachCursor();\n    if (!_opts.waitUntilVisible) {\n      _fire();\n      return this;\n    }\n    fireWhenVisible(_element, _fire.bind(this));\n    return this;\n  };\n  this.flush = function () {\n    let cb = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : () => {};\n    _attachCursor();\n    _fire(false).then(cb);\n    return this;\n  };\n  this.getQueue = () => _queue;\n  this.getOptions = () => _opts;\n  this.updateOptions = options2 => _options(options2);\n  this.getElement = () => _element;\n  let _element = selectorToElement(element);\n  let _timeouts = [];\n  let _cursorPosition = 0;\n  let _predictedCursorPosition = null;\n  let _statuses = merge({}, DEFAULT_STATUSES);\n  options.cursor = processCursorOptions(options.cursor ?? DEFAULT_OPTIONS.cursor);\n  let _opts = merge(DEFAULT_OPTIONS, options);\n  _opts = merge(_opts, {\n    html: !_elementIsInput() && _opts.html,\n    nextStringDelay: calculateDelay(_opts.nextStringDelay),\n    loopDelay: calculateDelay(_opts.loopDelay)\n  });\n  let _id = generateHash();\n  let _queue = Queue([{\n    delay: _opts.startDelay\n  }]);\n  _element.dataset.typeitId = _id;\n  appendStyleBlock(PLACEHOLDER_CSS);\n  let _shouldRenderCursor = !!_opts.cursor && !_elementIsInput();\n  let _cursor = _setUpCursor();\n  _opts.strings = _maybePrependHardcodedStrings(asArray(_opts.strings));\n  if (_opts.strings.length) {\n    _generateQueue();\n  }\n};\nconst defaultProps = {\n  as: \"span\",\n  options: {},\n  getBeforeInit: instance => instance,\n  getAfterInit: instance => instance\n};\nconst DynamicElementComponent = forwardRef((props, ref) => {\n  const {\n    as: As\n  } = props;\n  return /* @__PURE__ */React.createElement(As, {\n    ref,\n    ...props\n  });\n});\nconst TypeIt = props => {\n  const elementRef = useRef(null);\n  const instanceRef = useRef(null);\n  const {\n    options,\n    children,\n    getBeforeInit,\n    getAfterInit,\n    ...remainingProps\n  } = props;\n  const [shouldShowChildren, setShouldShowChildren] = useState(true);\n  const [instanceOptions, setInstanceOptions] = useState(null);\n  function calculateOptions() {\n    const optionsClone = Object.assign({}, options);\n    if (children && elementRef.current) {\n      optionsClone.strings = elementRef.current.innerHTML;\n    }\n    setInstanceOptions(optionsClone);\n  }\n  function generateNewInstance() {\n    instanceRef.current = new TypeIt$1(elementRef.current, instanceOptions);\n    instanceRef.current = getBeforeInit(instanceRef.current);\n    instanceRef.current.go();\n    instanceRef.current = getAfterInit(instanceRef.current);\n  }\n  useEffect(() => {\n    calculateOptions();\n    setShouldShowChildren(false);\n  }, [options]);\n  useEffect(() => {\n    var _a;\n    if (!instanceOptions) return;\n    ((_a = instanceRef.current) == null ? void 0 : _a.updateOptions(instanceOptions)) || generateNewInstance();\n  }, [instanceOptions]);\n  useEffect(() => {\n    return () => {\n      var _a;\n      return (_a = instanceRef.current) == null ? void 0 : _a.destroy();\n    };\n  }, []);\n  return /* @__PURE__ */React.createElement(DynamicElementComponent, {\n    ref: elementRef,\n    children: shouldShowChildren ? children : null,\n    style: {\n      opacity: shouldShowChildren ? 0 : 1\n    },\n    ...remainingProps\n  });\n};\nTypeIt.defaultProps = defaultProps;\nexport { TypeIt as default };","map":{"version":3,"names":["React","forwardRef","useRef","useState","useEffect","isArray","thing","Array","asArray","value","Queue","initialItems","add","steps","forEach","step","_a","_q","set","Symbol","char","innerText","buildQueueItem","getTypeable","rawValues","filter","typeable","index","item","keys","queueItem","shouldPauseCursor","Boolean","cursorable","deletable","reset","done","wipe","Map","getQueue","from","values","destroy","key","delete","getItems","all","arguments","length","undefined","i","shouldDestroy","get","toArray","val","createTextNode","content","document","expandTextNodes","element","childNodes","child","nodeValue","c","parentNode","insertBefore","remove","getParsedBody","doc","implementation","createHTMLDocument","body","innerHTML","DATA_ATTRIBUTE","CURSOR_CLASS","END","DEFAULT_STATUSES","started","completed","frozen","destroyed","DEFAULT_OPTIONS","breakLines","cursor","autoPause","autoPauseDelay","animation","frames","map","n","opacity","options","iterations","Infinity","easing","fill","cursorChar","cursorSpeed","deleteSpeed","html","lifeLike","loop","loopDelay","nextStringDelay","speed","startDelay","startDelete","strings","waitUntilVisible","beforeString","afterString","beforeStep","afterStep","afterComplete","PLACEHOLDER_CSS","walkElementNodes","shouldReverse","shouldIncludeCursor","querySelector","walker","createTreeWalker","NodeFilter","SHOW_ALL","acceptNode","node","_b","classList","contains","FILTER_ACCEPT","FILTER_REJECT","nextNode","nodes","originalParent","push","reverse","chunkStringAsHtml","string","maybeChunkStringAsHtml","str","asHtml","createElement","el","appendStyleBlock","styles","id","styleBlock","appendChild","head","calculateDelay","delayArg","randomInRange","range2","Math","abs","random","range","calculatePace","destroyTimeouts","timeouts","clearTimeout","generateHash","toString","substring","isInput","getAllChars","fireWhenVisible","func","observer","IntersectionObserver","entries","observer2","entry","isIntersecting","unobserve","threshold","observe","handleFunctionalArg","arg","isNumber","Number","isInteger","select","selector","isBodyElement","test","tagName","insertIntoElement","originalTarget","character","textContent","target","updateCursorPosition","cursorPosition","printedCharacters","min","max","merge","originalObj","newObj","Object","assign","removeNode","rootElement","nodeParent","nodeToRemove","isSameNode","repositionCursor","allChars","newCursorPosition","nodeToInsertBefore","selectorToElement","isNonVoidElement","outerHTML","wait","callback","delay","Promise","resolve","cb","setTimeout","cursorFontStyles","color","transform","setCursorStyles","rootSelector","cursorSelector","computedStyles","getComputedStyle","customProperties","reduce","accumulator","_ref","duplicate","times","countStepsToSelector","_ref2","queueItems","to","isMovingToEnd","RegExp","selectorIndex","findIndex","_ref3","parentElement","parentMatches","matches","firstChild","offset","beforePaint","requestAnimationFrame","getAnimationFromElement","getAnimations","find","dataset","tiAnimationId","setCursorAnimation","_ref4","animate","pause","play","rebuildCursorAnimation","_ref5","cursorOptions","oldCurrentTime","effect","getComputedTiming","currentTime","cancel","newAnimation","execute","call","fireItem","_ref6","wait2","instantQueue","tempIndex","futureItem","shouldBeGrouped","q","processCursorOptions","newOptions","defaultFrames","defaultOptions","TypeIt$1","_this","_wait","silent","_statuses","unfreeze","_opts","_timeouts","_fireItemWithContext","_cursor","_removeNode","_element","_elementIsInput","_getPace","_getAllChars","_maybeAppendPause","opts","_queue","_queueAndReturn","_getDerivedCursorPosition","_predictedCursorPosition","_cursorPosition","_generateTemporaryOptionQueueItems","_options","_addSplitPause","items","_setUpCursor","className","_shouldRenderCursor","style","visibility","_attachCursor","_id","options2","duration","_generateQueue","type","splitItems","_type","_delete","_prepLoop","derivedCursorPosition","_move","_maybePrependHardcodedStrings","existingMarkup","hardCodedStrings","replace","trim","split","concat","_fire","remember","cleanUp","qKey","queueKey","newIndex","x","y","e","_empty","slice","break","actionOpts","numCharacters","bookEndQueueItems","num","instant","typeableQueueItems","rounds","empty","exec","move","movementArg","numberOfSteps","directionalStep","milliseconds","chars","charsAsQueueItems","nodeType","Node","TEXT_NODE","itemsToQueue","is","shouldRemoveCursor","freeze","rebuild","property","go","bind","flush","then","getOptions","updateOptions","getElement","typeitId","defaultProps","as","getBeforeInit","instance","getAfterInit","DynamicElementComponent","props","ref","As","TypeIt","elementRef","instanceRef","children","remainingProps","shouldShowChildren","setShouldShowChildren","instanceOptions","setInstanceOptions","calculateOptions","optionsClone","current","generateNewInstance","default"],"sources":["/Users/behzad/Desktop/swr/node_modules/typeit-react/dist/index.es.js"],"sourcesContent":["import React, { forwardRef, useRef, useState, useEffect } from \"react\";\nconst isArray = (thing) => Array.isArray(thing);\nconst asArray = (value) => {\n  return isArray(value) ? value : [value];\n};\nlet Queue = function(initialItems) {\n  let add = function(steps) {\n    asArray(steps).forEach((step) => {\n      var _a;\n      return _q.set(Symbol((_a = step.char) == null ? void 0 : _a.innerText), buildQueueItem({ ...step }));\n    });\n    return this;\n  };\n  let getTypeable = () => rawValues().filter((value) => value.typeable);\n  let set = function(index, item) {\n    let keys = [..._q.keys()];\n    _q.set(keys[index], buildQueueItem(item));\n  };\n  let buildQueueItem = (queueItem) => {\n    queueItem.shouldPauseCursor = function() {\n      return Boolean(this.typeable || this.cursorable || this.deletable);\n    };\n    return queueItem;\n  };\n  let reset = function() {\n    _q.forEach((item) => delete item.done);\n  };\n  let wipe = function() {\n    _q = /* @__PURE__ */ new Map();\n    add(initialItems);\n  };\n  let getQueue = () => _q;\n  let rawValues = () => Array.from(_q.values());\n  let destroy = (key) => _q.delete(key);\n  let getItems = (all = false) => all ? rawValues() : rawValues().filter((i) => !i.done);\n  let done = (key, shouldDestroy = false) => shouldDestroy ? _q.delete(key) : _q.get(key).done = true;\n  let _q = /* @__PURE__ */ new Map();\n  add(initialItems);\n  return {\n    add,\n    set,\n    wipe,\n    reset,\n    destroy,\n    done,\n    getItems,\n    getQueue,\n    getTypeable\n  };\n};\nconst toArray = (val) => Array.from(val);\nconst createTextNode = (content) => document.createTextNode(content);\nlet expandTextNodes = (element) => {\n  [...element.childNodes].forEach((child) => {\n    if (child.nodeValue) {\n      [...child.nodeValue].forEach((c) => {\n        child.parentNode.insertBefore(createTextNode(c), child);\n      });\n      child.remove();\n      return;\n    }\n    expandTextNodes(child);\n  });\n  return element;\n};\nconst getParsedBody = (content) => {\n  let doc = document.implementation.createHTMLDocument();\n  doc.body.innerHTML = content;\n  return expandTextNodes(doc.body);\n};\nconst DATA_ATTRIBUTE = \"data-typeit-id\";\nconst CURSOR_CLASS = \"ti-cursor\";\nconst END = \"END\";\nconst DEFAULT_STATUSES = {\n  started: false,\n  completed: false,\n  frozen: false,\n  destroyed: false\n};\nconst DEFAULT_OPTIONS = {\n  breakLines: true,\n  cursor: {\n    autoPause: true,\n    autoPauseDelay: 500,\n    animation: {\n      frames: [0, 0, 1].map((n) => {\n        return { opacity: n };\n      }),\n      options: {\n        iterations: Infinity,\n        easing: \"steps(2, start)\",\n        fill: \"forwards\"\n      }\n    }\n  },\n  cursorChar: \"|\",\n  cursorSpeed: 1e3,\n  deleteSpeed: null,\n  html: true,\n  lifeLike: true,\n  loop: false,\n  loopDelay: 750,\n  nextStringDelay: 750,\n  speed: 100,\n  startDelay: 250,\n  startDelete: false,\n  strings: [],\n  waitUntilVisible: false,\n  beforeString: () => {\n  },\n  afterString: () => {\n  },\n  beforeStep: () => {\n  },\n  afterStep: () => {\n  },\n  afterComplete: () => {\n  }\n};\nconst PLACEHOLDER_CSS = `[${DATA_ATTRIBUTE}]:before {content: '.'; display: inline-block; width: 0; visibility: hidden;}`;\nfunction walkElementNodes(element, shouldReverse = false, shouldIncludeCursor = false) {\n  let cursor = element.querySelector(`.${CURSOR_CLASS}`);\n  let walker = document.createTreeWalker(element, NodeFilter.SHOW_ALL, {\n    acceptNode: (node) => {\n      var _a, _b;\n      if (cursor && shouldIncludeCursor) {\n        if ((_a = node.classList) == null ? void 0 : _a.contains(CURSOR_CLASS)) {\n          return NodeFilter.FILTER_ACCEPT;\n        }\n        if (cursor.contains(node)) {\n          return NodeFilter.FILTER_REJECT;\n        }\n      }\n      return ((_b = node.classList) == null ? void 0 : _b.contains(CURSOR_CLASS)) ? NodeFilter.FILTER_REJECT : NodeFilter.FILTER_ACCEPT;\n    }\n  });\n  let nextNode;\n  let nodes = [];\n  while (nextNode = walker.nextNode()) {\n    if (!nextNode.originalParent) {\n      nextNode.originalParent = nextNode.parentNode;\n    }\n    nodes.push(nextNode);\n  }\n  return shouldReverse ? nodes.reverse() : nodes;\n}\nfunction chunkStringAsHtml(string) {\n  return walkElementNodes(getParsedBody(string));\n}\nfunction maybeChunkStringAsHtml(str, asHtml = true) {\n  return asHtml ? chunkStringAsHtml(str) : toArray(str).map(createTextNode);\n}\nconst createElement = (el) => document.createElement(el);\nconst appendStyleBlock = (styles, id = \"\") => {\n  let styleBlock = createElement(\"style\");\n  styleBlock.id = id;\n  styleBlock.appendChild(createTextNode(styles));\n  document.head.appendChild(styleBlock);\n};\nconst calculateDelay = (delayArg) => {\n  if (!isArray(delayArg)) {\n    delayArg = [delayArg / 2, delayArg / 2];\n  }\n  return delayArg;\n};\nconst randomInRange = (value, range2) => {\n  return Math.abs(\n    Math.random() * (value + range2 - (value - range2)) + (value - range2)\n  );\n};\nlet range = (val) => val / 2;\nfunction calculatePace(options) {\n  let { speed, deleteSpeed, lifeLike } = options;\n  deleteSpeed = deleteSpeed !== null ? deleteSpeed : speed / 3;\n  return lifeLike ? [\n    randomInRange(speed, range(speed)),\n    randomInRange(deleteSpeed, range(deleteSpeed))\n  ] : [speed, deleteSpeed];\n}\nconst destroyTimeouts = (timeouts) => {\n  timeouts.forEach(clearTimeout);\n  return [];\n};\nconst generateHash = () => Math.random().toString().substring(2, 9);\nconst isInput = (el) => \"value\" in el;\nlet getAllChars = (element) => {\n  if (isInput(element)) {\n    return toArray(element.value);\n  }\n  return walkElementNodes(element, true).filter(\n    (c) => !(c.childNodes.length > 0)\n  );\n};\nconst fireWhenVisible = (element, func) => {\n  let observer = new IntersectionObserver(\n    (entries, observer2) => {\n      entries.forEach((entry) => {\n        if (entry.isIntersecting) {\n          func();\n          observer2.unobserve(element);\n        }\n      });\n    },\n    { threshold: 1 }\n  );\n  observer.observe(element);\n};\nlet handleFunctionalArg = (arg) => {\n  return typeof arg === \"function\" ? arg() : arg;\n};\nconst isNumber = (value) => Number.isInteger(value);\nlet select = (selector, element = document, all = false) => {\n  return element[`querySelector${all ? \"All\" : \"\"}`](selector);\n};\nlet isBodyElement = (node) => /body/i.test(node == null ? void 0 : node.tagName);\nlet insertIntoElement = (originalTarget, character) => {\n  if (isInput(originalTarget)) {\n    originalTarget.value = `${originalTarget.value}${character.textContent}`;\n    return;\n  }\n  character.innerHTML = \"\";\n  let target = isBodyElement(character.originalParent) ? originalTarget : character.originalParent || originalTarget;\n  target.insertBefore(\n    character,\n    select(\".\" + CURSOR_CLASS, target) || null\n  );\n};\nlet updateCursorPosition = (steps, cursorPosition, printedCharacters) => {\n  return Math.min(\n    Math.max(cursorPosition + steps, 0),\n    printedCharacters.length\n  );\n};\nconst merge = (originalObj, newObj) => Object.assign({}, originalObj, newObj);\nconst removeNode = (node, rootElement) => {\n  if (!node)\n    return;\n  let nodeParent = node.parentNode;\n  let nodeToRemove = nodeParent.childNodes.length > 1 || nodeParent.isSameNode(rootElement) ? node : nodeParent;\n  nodeToRemove.remove();\n};\nconst repositionCursor = (element, allChars, newCursorPosition) => {\n  let nodeToInsertBefore = allChars[newCursorPosition - 1];\n  let cursor = select(`.${CURSOR_CLASS}`, element);\n  element = (nodeToInsertBefore == null ? void 0 : nodeToInsertBefore.parentNode) || element;\n  element.insertBefore(cursor, nodeToInsertBefore || null);\n};\nfunction selectorToElement(thing) {\n  return typeof thing === \"string\" ? select(thing) : thing;\n}\nconst isNonVoidElement = (el) => /<(.+)>(.*?)<\\/(.+)>/.test(el.outerHTML);\nlet wait = (callback, delay, timeouts) => {\n  return new Promise((resolve) => {\n    let cb = async () => {\n      await callback();\n      resolve();\n    };\n    timeouts.push(setTimeout(cb, delay || 0));\n  });\n};\nlet cursorFontStyles = {\n  \"font-family\": \"\",\n  \"font-weight\": \"\",\n  \"font-size\": \"\",\n  \"font-style\": \"\",\n  \"line-height\": \"\",\n  color: \"\",\n  transform: \"translateX(-.125em)\"\n};\nlet setCursorStyles = (id, element) => {\n  let rootSelector = `[${DATA_ATTRIBUTE}='${id}']`;\n  let cursorSelector = `${rootSelector} .${CURSOR_CLASS}`;\n  let computedStyles = getComputedStyle(element);\n  let customProperties = Object.entries(cursorFontStyles).reduce(\n    (accumulator, [item, value]) => {\n      return `${accumulator} ${item}: var(--ti-cursor-${item}, ${value || computedStyles[item]});`;\n    },\n    \"\"\n  );\n  appendStyleBlock(\n    `${cursorSelector} { display: inline-block; width: 0; ${customProperties} }`,\n    id\n  );\n};\nconst duplicate = (value, times) => new Array(times).fill(value);\nconst countStepsToSelector = ({\n  queueItems,\n  selector,\n  cursorPosition,\n  to\n}) => {\n  if (isNumber(selector)) {\n    return selector * -1;\n  }\n  let isMovingToEnd = new RegExp(END, \"i\").test(to);\n  let selectorIndex = selector ? [...queueItems].reverse().findIndex(({ char }) => {\n    let parentElement = char.parentElement;\n    let parentMatches = parentElement.matches(selector);\n    if (isMovingToEnd && parentMatches) {\n      return true;\n    }\n    return parentMatches && parentElement.firstChild.isSameNode(char);\n  }) : -1;\n  if (selectorIndex < 0) {\n    selectorIndex = isMovingToEnd ? 0 : queueItems.length - 1;\n  }\n  let offset = isMovingToEnd ? 0 : 1;\n  return selectorIndex - cursorPosition + offset;\n};\nlet beforePaint = (cb) => {\n  return new Promise((resolve) => {\n    requestAnimationFrame(async () => {\n      resolve(await cb());\n    });\n  });\n};\nlet getAnimationFromElement = (element) => {\n  return element == null ? void 0 : element.getAnimations().find((animation) => {\n    return animation.id === element.dataset.tiAnimationId;\n  });\n};\nlet setCursorAnimation = ({\n  cursor,\n  frames,\n  options\n}) => {\n  let animation = cursor.animate(frames, options);\n  animation.pause();\n  animation.id = cursor.dataset.tiAnimationId;\n  beforePaint(() => {\n    beforePaint(() => {\n      animation.play();\n    });\n  });\n  return animation;\n};\nlet rebuildCursorAnimation = ({\n  cursor,\n  options,\n  cursorOptions\n}) => {\n  if (!cursor || !cursorOptions)\n    return;\n  let animation = getAnimationFromElement(cursor);\n  let oldCurrentTime;\n  if (animation) {\n    options.delay = animation.effect.getComputedTiming().delay;\n    oldCurrentTime = animation.currentTime;\n    animation.cancel();\n  }\n  let newAnimation = setCursorAnimation({\n    cursor,\n    frames: cursorOptions.animation.frames,\n    options\n  });\n  if (oldCurrentTime) {\n    newAnimation.currentTime = oldCurrentTime;\n  }\n  return newAnimation;\n};\nlet execute = (queueItem) => {\n  var _a;\n  return (_a = queueItem.func) == null ? void 0 : _a.call(null);\n};\nlet fireItem = async ({\n  index,\n  queueItems,\n  wait: wait2,\n  cursor,\n  cursorOptions\n}) => {\n  let queueItem = queueItems[index][1];\n  let instantQueue = [];\n  let tempIndex = index;\n  let futureItem = queueItem;\n  let shouldBeGrouped = () => futureItem && !futureItem.delay;\n  let shouldPauseCursor = queueItem.shouldPauseCursor() && cursorOptions.autoPause;\n  while (shouldBeGrouped()) {\n    instantQueue.push(futureItem);\n    shouldBeGrouped() && tempIndex++;\n    futureItem = queueItems[tempIndex] ? queueItems[tempIndex][1] : null;\n  }\n  if (instantQueue.length) {\n    await beforePaint(async () => {\n      for (let q of instantQueue) {\n        await execute(q);\n      }\n    });\n    return tempIndex - 1;\n  }\n  let animation = getAnimationFromElement(cursor);\n  let options;\n  if (animation) {\n    options = {\n      ...animation.effect.getComputedTiming(),\n      delay: shouldPauseCursor ? cursorOptions.autoPauseDelay : 0\n    };\n  }\n  await wait2(async () => {\n    if (animation && shouldPauseCursor) {\n      animation.cancel();\n    }\n    await beforePaint(() => {\n      execute(queueItem);\n    });\n  }, queueItem.delay);\n  await rebuildCursorAnimation({\n    cursor,\n    options,\n    cursorOptions\n  });\n  return index;\n};\nlet processCursorOptions = (cursorOptions) => {\n  var _a, _b;\n  if (typeof cursorOptions === \"object\") {\n    let newOptions = {};\n    let { frames: defaultFrames, options: defaultOptions } = DEFAULT_OPTIONS.cursor.animation;\n    newOptions.animation = cursorOptions.animation || {};\n    newOptions.animation.frames = ((_a = cursorOptions.animation) == null ? void 0 : _a.frames) || defaultFrames;\n    newOptions.animation.options = merge(\n      defaultOptions,\n      ((_b = cursorOptions.animation) == null ? void 0 : _b.options) || {}\n    );\n    newOptions.autoPause = cursorOptions.autoPause ?? DEFAULT_OPTIONS.cursor.autoPause;\n    newOptions.autoPauseDelay = cursorOptions.autoPauseDelay || DEFAULT_OPTIONS.cursor.autoPauseDelay;\n    return newOptions;\n  }\n  if (cursorOptions === true) {\n    return DEFAULT_OPTIONS.cursor;\n  }\n  return cursorOptions;\n};\nconst TypeIt$1 = function(element, options = {}) {\n  let _wait = async (callback, delay, silent = false) => {\n    if (_statuses.frozen) {\n      await new Promise((resolve) => {\n        this.unfreeze = () => {\n          _statuses.frozen = false;\n          resolve();\n        };\n      });\n    }\n    silent || await _opts.beforeStep(this);\n    await wait(callback, delay, _timeouts);\n    silent || await _opts.afterStep(this);\n  };\n  let _fireItemWithContext = (index, queueItems) => {\n    return fireItem({\n      index,\n      queueItems,\n      wait: _wait,\n      cursor: _cursor,\n      cursorOptions: _opts.cursor\n    });\n  };\n  let _removeNode = (node) => removeNode(node, _element);\n  let _elementIsInput = () => isInput(_element);\n  let _getPace = (index = 0) => calculatePace(_opts)[index];\n  let _getAllChars = () => getAllChars(_element);\n  let _maybeAppendPause = (opts = {}) => {\n    let delay = opts.delay;\n    delay && _queue.add({ delay });\n  };\n  let _queueAndReturn = (steps, opts) => {\n    _queue.add(steps);\n    _maybeAppendPause(opts);\n    return this;\n  };\n  let _getDerivedCursorPosition = () => _predictedCursorPosition ?? _cursorPosition;\n  let _generateTemporaryOptionQueueItems = (newOptions = {}) => {\n    return [\n      { func: () => _options(newOptions) },\n      { func: () => _options(_opts) }\n    ];\n  };\n  let _addSplitPause = (items) => {\n    let delay = _opts.nextStringDelay;\n    _queue.add([{ delay: delay[0] }, ...items, { delay: delay[1] }]);\n  };\n  let _setUpCursor = () => {\n    if (_elementIsInput()) {\n      return;\n    }\n    let cursor = createElement(\"span\");\n    cursor.className = CURSOR_CLASS;\n    if (!_shouldRenderCursor) {\n      cursor.style.visibility = \"hidden\";\n      return cursor;\n    }\n    cursor.innerHTML = getParsedBody(_opts.cursorChar).innerHTML;\n    return cursor;\n  };\n  let _attachCursor = async () => {\n    !_elementIsInput() && _cursor && _element.appendChild(_cursor);\n    if (_shouldRenderCursor) {\n      setCursorStyles(_id, _element);\n      _cursor.dataset.tiAnimationId = _id;\n      let { animation } = _opts.cursor;\n      let { frames, options: options2 } = animation;\n      setCursorAnimation({\n        frames,\n        cursor: _cursor,\n        options: {\n          duration: _opts.cursorSpeed,\n          ...options2\n        }\n      });\n    }\n  };\n  let _generateQueue = () => {\n    let strings = _opts.strings.filter((string) => !!string);\n    strings.forEach((string, index) => {\n      this.type(string);\n      if (index + 1 === strings.length) {\n        return;\n      }\n      let splitItems = _opts.breakLines ? [{ func: () => _type(createElement(\"BR\")), typeable: true }] : duplicate(\n        {\n          func: _delete,\n          delay: _getPace(1)\n        },\n        _queue.getTypeable().length\n      );\n      _addSplitPause(splitItems);\n    });\n  };\n  let _prepLoop = async (delay) => {\n    let derivedCursorPosition = _getDerivedCursorPosition();\n    derivedCursorPosition && await _move({ value: derivedCursorPosition });\n    let queueItems = _getAllChars().map((c) => {\n      return [\n        Symbol(),\n        {\n          func: _delete,\n          delay: _getPace(1),\n          deletable: true,\n          shouldPauseCursor: () => true\n        }\n      ];\n    });\n    for (let index = 0; index < queueItems.length; index++) {\n      await _fireItemWithContext(index, queueItems);\n    }\n    _queue.reset();\n    _queue.set(0, { delay });\n  };\n  let _maybePrependHardcodedStrings = (strings) => {\n    let existingMarkup = _element.innerHTML;\n    if (!existingMarkup) {\n      return strings;\n    }\n    _element.innerHTML = \"\";\n    if (_opts.startDelete) {\n      _element.innerHTML = existingMarkup;\n      expandTextNodes(_element);\n      _addSplitPause(\n        duplicate(\n          {\n            func: _delete,\n            delay: _getPace(1),\n            deletable: true\n          },\n          _getAllChars().length\n        )\n      );\n      return strings;\n    }\n    let hardCodedStrings = existingMarkup.replace(/<!--(.+?)-->/g, \"\").trim().split(/<br(?:\\s*?)(?:\\/)?>/);\n    return hardCodedStrings.concat(strings);\n  };\n  let _fire = async (remember = true) => {\n    _statuses.started = true;\n    let cleanUp = (qKey) => {\n      _queue.done(qKey, !remember);\n    };\n    try {\n      let queueItems = [..._queue.getQueue()];\n      for (let index = 0; index < queueItems.length; index++) {\n        let [queueKey, queueItem] = queueItems[index];\n        if (queueItem.done)\n          continue;\n        if (!queueItem.deletable || queueItem.deletable && _getAllChars().length) {\n          let newIndex = await _fireItemWithContext(index, queueItems);\n          Array(newIndex - index).fill(index + 1).map((x, y) => x + y).forEach((i) => {\n            let [key] = queueItems[i];\n            cleanUp(key);\n          });\n          index = newIndex;\n        }\n        cleanUp(queueKey);\n      }\n      if (!remember) {\n        return this;\n      }\n      _statuses.completed = true;\n      await _opts.afterComplete(this);\n      if (!_opts.loop) {\n        throw \"\";\n      }\n      let delay = _opts.loopDelay;\n      _wait(async () => {\n        await _prepLoop(delay[0]);\n        _fire();\n      }, delay[1]);\n    } catch (e) {\n    }\n    return this;\n  };\n  let _move = async (step) => {\n    _cursorPosition = updateCursorPosition(\n      step,\n      _cursorPosition,\n      _getAllChars()\n    );\n    repositionCursor(_element, _getAllChars(), _cursorPosition);\n  };\n  let _type = (char) => insertIntoElement(_element, char);\n  let _options = async (opts) => _opts = merge(_opts, opts);\n  let _empty = async () => {\n    if (_elementIsInput()) {\n      _element.value = \"\";\n      return;\n    }\n    _getAllChars().forEach(_removeNode);\n    return;\n  };\n  let _delete = () => {\n    let allChars = _getAllChars();\n    if (!allChars.length)\n      return;\n    if (_elementIsInput()) {\n      _element.value = _element.value.slice(0, -1);\n    } else {\n      _removeNode(allChars[_cursorPosition]);\n    }\n  };\n  this.break = function(actionOpts) {\n    return _queueAndReturn(\n      {\n        func: () => _type(createElement(\"BR\")),\n        typeable: true\n      },\n      actionOpts\n    );\n  };\n  this.delete = function(numCharacters = null, actionOpts = {}) {\n    numCharacters = handleFunctionalArg(numCharacters);\n    let bookEndQueueItems = _generateTemporaryOptionQueueItems(actionOpts);\n    let num = numCharacters;\n    let { instant, to } = actionOpts;\n    let typeableQueueItems = _queue.getTypeable();\n    let rounds = (() => {\n      if (num === null) {\n        return typeableQueueItems.length;\n      }\n      if (isNumber(num)) {\n        return num;\n      }\n      return countStepsToSelector({\n        queueItems: typeableQueueItems,\n        selector: num,\n        cursorPosition: _getDerivedCursorPosition(),\n        to\n      });\n    })();\n    return _queueAndReturn(\n      [\n        bookEndQueueItems[0],\n        ...duplicate(\n          {\n            func: _delete,\n            delay: instant ? 0 : _getPace(1),\n            deletable: true\n          },\n          rounds\n        ),\n        bookEndQueueItems[1]\n      ],\n      actionOpts\n    );\n  };\n  this.empty = function(actionOpts = {}) {\n    return _queueAndReturn({ func: _empty }, actionOpts);\n  };\n  this.exec = function(func, actionOpts = {}) {\n    let bookEndQueueItems = _generateTemporaryOptionQueueItems(actionOpts);\n    return _queueAndReturn(\n      [bookEndQueueItems[0], { func: () => func(this) }, bookEndQueueItems[1]],\n      actionOpts\n    );\n  };\n  this.move = function(movementArg, actionOpts = {}) {\n    movementArg = handleFunctionalArg(movementArg);\n    let bookEndQueueItems = _generateTemporaryOptionQueueItems(actionOpts);\n    let { instant, to } = actionOpts;\n    let numberOfSteps = countStepsToSelector({\n      queueItems: _queue.getTypeable(),\n      selector: movementArg === null ? \"\" : movementArg,\n      to,\n      cursorPosition: _getDerivedCursorPosition()\n    });\n    let directionalStep = numberOfSteps < 0 ? -1 : 1;\n    _predictedCursorPosition = _getDerivedCursorPosition() + numberOfSteps;\n    return _queueAndReturn(\n      [\n        bookEndQueueItems[0],\n        ...duplicate(\n          {\n            func: () => _move(directionalStep),\n            delay: instant ? 0 : _getPace(),\n            cursorable: true\n          },\n          Math.abs(numberOfSteps)\n        ),\n        bookEndQueueItems[1]\n      ],\n      actionOpts\n    );\n  };\n  this.options = function(opts, actionOpts = {}) {\n    opts = handleFunctionalArg(opts);\n    _options(opts);\n    return _queueAndReturn({}, actionOpts);\n  };\n  this.pause = function(milliseconds, actionOpts = {}) {\n    return _queueAndReturn(\n      { delay: handleFunctionalArg(milliseconds) },\n      actionOpts\n    );\n  };\n  this.type = function(string, actionOpts = {}) {\n    string = handleFunctionalArg(string);\n    let { instant } = actionOpts;\n    let bookEndQueueItems = _generateTemporaryOptionQueueItems(actionOpts);\n    let chars = maybeChunkStringAsHtml(string, _opts.html);\n    let charsAsQueueItems = chars.map((char) => {\n      return {\n        func: () => _type(char),\n        char,\n        delay: instant || isNonVoidElement(char) ? 0 : _getPace(),\n        typeable: char.nodeType === Node.TEXT_NODE\n      };\n    });\n    let itemsToQueue = [\n      bookEndQueueItems[0],\n      { func: async () => await _opts.beforeString(string, this) },\n      ...charsAsQueueItems,\n      { func: async () => await _opts.afterString(string, this) },\n      bookEndQueueItems[1]\n    ];\n    return _queueAndReturn(itemsToQueue, actionOpts);\n  };\n  this.is = function(key) {\n    return _statuses[key];\n  };\n  this.destroy = function(shouldRemoveCursor = true) {\n    _timeouts = destroyTimeouts(_timeouts);\n    handleFunctionalArg(shouldRemoveCursor) && _cursor && _removeNode(_cursor);\n    _statuses.destroyed = true;\n  };\n  this.freeze = function() {\n    _statuses.frozen = true;\n  };\n  this.unfreeze = () => {\n  };\n  this.reset = function(rebuild) {\n    !this.is(\"destroyed\") && this.destroy();\n    if (rebuild) {\n      _queue.wipe();\n      rebuild(this);\n    } else {\n      _queue.reset();\n    }\n    _cursorPosition = 0;\n    for (let property in _statuses) {\n      _statuses[property] = false;\n    }\n    _element[_elementIsInput() ? \"value\" : \"innerHTML\"] = \"\";\n    return this;\n  };\n  this.go = function() {\n    if (_statuses.started) {\n      return this;\n    }\n    _attachCursor();\n    if (!_opts.waitUntilVisible) {\n      _fire();\n      return this;\n    }\n    fireWhenVisible(_element, _fire.bind(this));\n    return this;\n  };\n  this.flush = function(cb = () => {\n  }) {\n    _attachCursor();\n    _fire(false).then(cb);\n    return this;\n  };\n  this.getQueue = () => _queue;\n  this.getOptions = () => _opts;\n  this.updateOptions = (options2) => _options(options2);\n  this.getElement = () => _element;\n  let _element = selectorToElement(element);\n  let _timeouts = [];\n  let _cursorPosition = 0;\n  let _predictedCursorPosition = null;\n  let _statuses = merge({}, DEFAULT_STATUSES);\n  options.cursor = processCursorOptions(\n    options.cursor ?? DEFAULT_OPTIONS.cursor\n  );\n  let _opts = merge(DEFAULT_OPTIONS, options);\n  _opts = merge(_opts, {\n    html: !_elementIsInput() && _opts.html,\n    nextStringDelay: calculateDelay(_opts.nextStringDelay),\n    loopDelay: calculateDelay(_opts.loopDelay)\n  });\n  let _id = generateHash();\n  let _queue = Queue([{ delay: _opts.startDelay }]);\n  _element.dataset.typeitId = _id;\n  appendStyleBlock(PLACEHOLDER_CSS);\n  let _shouldRenderCursor = !!_opts.cursor && !_elementIsInput();\n  let _cursor = _setUpCursor();\n  _opts.strings = _maybePrependHardcodedStrings(asArray(_opts.strings));\n  if (_opts.strings.length) {\n    _generateQueue();\n  }\n};\nconst defaultProps = {\n  as: \"span\",\n  options: {},\n  getBeforeInit: (instance) => instance,\n  getAfterInit: (instance) => instance\n};\nconst DynamicElementComponent = forwardRef((props, ref) => {\n  const { as: As } = props;\n  return /* @__PURE__ */ React.createElement(As, { ref, ...props });\n});\nconst TypeIt = (props) => {\n  const elementRef = useRef(null);\n  const instanceRef = useRef(null);\n  const { options, children, getBeforeInit, getAfterInit, ...remainingProps } = props;\n  const [shouldShowChildren, setShouldShowChildren] = useState(true);\n  const [instanceOptions, setInstanceOptions] = useState(null);\n  function calculateOptions() {\n    const optionsClone = Object.assign({}, options);\n    if (children && elementRef.current) {\n      optionsClone.strings = elementRef.current.innerHTML;\n    }\n    setInstanceOptions(optionsClone);\n  }\n  function generateNewInstance() {\n    instanceRef.current = new TypeIt$1(elementRef.current, instanceOptions);\n    instanceRef.current = getBeforeInit(instanceRef.current);\n    instanceRef.current.go();\n    instanceRef.current = getAfterInit(instanceRef.current);\n  }\n  useEffect(() => {\n    calculateOptions();\n    setShouldShowChildren(false);\n  }, [options]);\n  useEffect(() => {\n    var _a;\n    if (!instanceOptions)\n      return;\n    ((_a = instanceRef.current) == null ? void 0 : _a.updateOptions(instanceOptions)) || generateNewInstance();\n  }, [instanceOptions]);\n  useEffect(() => {\n    return () => {\n      var _a;\n      return (_a = instanceRef.current) == null ? void 0 : _a.destroy();\n    };\n  }, []);\n  return /* @__PURE__ */ React.createElement(\n    DynamicElementComponent,\n    {\n      ref: elementRef,\n      children: shouldShowChildren ? children : null,\n      style: { opacity: shouldShowChildren ? 0 : 1 },\n      ...remainingProps\n    }\n  );\n};\nTypeIt.defaultProps = defaultProps;\nexport {\n  TypeIt as default\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}